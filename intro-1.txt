ESEUR Workshop - Introduction
=============================
:author:    Derek M. Jones
:copyright: Somebody
:backend:   slidy
:max-width: 45em

Overview
--------

{nbsp}

Me talking

You doing

--------
10:30-12:00 Talking
12:00-13:30 Doing+lunch
13:30-14:30 Talking
14:30-15:30 Doing
15:30-16:30 Talking
16:30-17:30 Doing
--------

Aims
----

{nbsp}

Useful to practicing software developer

* analyse your own data
* better understanding of software development processes

{nbsp}

Minimise what developers have to know

* developers are part-time data analyzers

Approach
--------

{nbsp}

A doctor's approach to curing patient problems

* what are the symptoms
* do this and you should be cured

{nbsp}

A few general techniques covering many cases

* needs a computer
* uses R
* try to fit in with existing developer knowledge

{nbsp}

Driven by data

Always remember
---------------

{nbsp}

<quote>Output of statistical analysis should be treated as a guide and not a mandate</quote>

{nbsp}

<quote>All models are wrong, but some are useful</quote>

Why R?
------

{nbsp}

It works and is usable

* mostly stats + some programming -> R
* mostly programming + some stats -> Python

{nbsp}

Very large, growing community

{nbsp}

Active discussion groups:

* https://stats.stackexchange.com/[Cross Validated]

* https://www.r-project.org/mail.html[mailing lists]

Lots of books

{nbsp}

Wide range of library packages

Brief introduction to R
-----------------------

{nbsp}

Small language, large library

Programs tend to be short

* no support for programming in the large

Operates on vectors

Fortran parentage with strong functional flavor

A few object-oriented features

* function overloading

Derived from S in 1990s, which came out of Bell Labs in 1970s

R Implementations
-----------------

{nbsp}

R - The R-project

* interpreted
* interactive command line/batch mode
* byte code compiler started shipping few years ago

{nbsp}

Go faster efforts focused on packages

* low level maths in C and Fortran
* custom written parallel-processoring functions

Language differences
--------------------

Fortran parentage

* arrays start at 1, not 0
* row-column order (not column-row) <rcode>df[row, column]</rcode>
* operator precedence

Identifiers

* Case is significant, <rcode>A_var != a_var</rcode>
* <rcode>names.can.contain...</rcode>

Semantic view of code, not a machine representation view

<rcode><<-</rcode> operator to assign to global variables

The Language
------------

{nbsp}

No statements, only expressions

[source,R]
-----
x = if (y < 1) 1 else 2
-----

<rcode>return</rcode>, <rcode>switch</rcode> are function calls

<rcode>continue</rcode> -> <rcode>next</rcode>

{nbsp}

Variables are implicitly defined when assigned to

<rcode>x=1  ; x="abc"</rcode>

{nbsp}

<rcode>x=function(p1, p2) { return(p1+p2) }</rcode>

Types
-----

{nbsp}

boolean, character, integer (32-bit), reals (64-bit), raw

arrays, data.table, lists, function, formula, expression

<rcode>as.character</rcode>, <rcode>as.numeric</rcode>, <rcode>as.integer</rcode>, <rcode>as.array</rcode>, <rcode>as.list</rcode>, ...

{nbsp}

Driven by semantics, not underlying representation

* <rcode>typeof</rcode>, <rcode>mode</rcode>
* <rcode>as.integer("1"); as.integer("a")</rcode>

<rcode>NA</rcode>, <rcode>NULL</rcode>

Expressions
-----------

{nbsp}

No scalars, literals are vectors of length one

* <rcode>3</rcode> equivalent to <rcode>c(3)</rcode>
* <rcode>1:5</rcode>  equivalent to <rcode>c(1, 2, 3, 4, 5)</rcode>

{nbsp}

Order of evaluation: left to right

<rcode>\$</rcode> member selection, <rcode>^</rcode> exponentiation

Vector operations
-----------------

[source,R]
-----
x = 2                   # vector containing one value
x = c(2, 4, 6, 8, 10)   # vector containing five values
# new vector containing the contents of x and two values
x = c(x, 12, 14)
y = vector(length=5)    # vector created by function call
y = 3:8                 # same as c(3, 4, 5, 6, 7, 8)
z = seq(from=3, to=13, by=3)      # sequence of values
-----

[source,R]
----
> x = 10:19
> x[2]
[1] 11
> x[-1]                        # exclude element 1
[1] 11 12 13 14 15 16 17 18 19
> x[12]                        # there is no 12'th element
[1] NA
> x[12]=100                    # there is now
> x
 [1]  10  11  12  13  14  15  16  17  18  19  NA 100
----

Extracting rows
---------------

[source,R]
----
> x = data.frame(num=c(1, 2, 3, 4), name=c("a", "b", "c", "d"))
> x
  num name
1   1    a
2   2    b
3   3    c
4   4    d
> # Have to remember that rows are indexed first and also specify x twice
> x[x$num > 2, ]
  num name
3   3    c
4   4    d
> # No need to remember row/column order and only specify x once
> subset(x, num > 2)
  num name
3   3    c
4   4    d
----

I/O
---

{nbsp}

File at a time input/output

{nbsp}

Lots of graphics systems/packages

{nbsp}

<rcode>cat</rcode>, simpler and more flexible than <rcode>print</rcode>

read.csv
--------

{nbsp}

<rcode>
data=read.csv("measurements.csv")
data=read.csv("measurements.csv.xz")
data=read.csv("measurements.csv", sep="|")
data=read.csv("https://github.com/Derek-Jones/ESEUR-code-data/blob/master/benchmark/MSTR10-DIMM.csv.xz")
</rcode>


plotting
--------

{nbsp}

<rcode>plot</rcode>

{nbsp}

<rcode>ggplot</rcode>

Base system functions
---------------------

{nbsp}

<rcode>nrow</rcode>, <rcode>ncol</rcode>, <rcode>length</rcode>,
<rcode>nchar</rcode>, ...

{nbsp}

<rcode>diff</rcode>, <rcode>grep</rcode>, <rcode>order</rcode>,
<rcode>sort</rcode>, <rcode>rle</rcode>, ...

{nbsp}

<rcode>summary</rcode>, <rcode>sum</rcode>, <rcode>sd</rcode>,
<rcode>max</rcode>, <rcode>min</rcode>, ...

Useful functions for debugging
------------------------------

{nbsp}

<rcode>cat</rcode>

{nbsp}

<rcode>str</rcode>

{nbsp}

<rcode>head</rcode>

{nbsp}

<rcode>table</rcode>

Structure of SE programs in R
-----------------------------

{nbsp}

[source,R]
-----
orig_data=read_data()

interesting_data=reshape_data(orig_data)

stat_results=appropriate_statistics(interesting_data)

plot_result(stat_results)
-----

Data analysis
-------------

{nbsp}

Clean data

* most of the time spent here

Find patterns in data

* knowledge of the subject
* suggested by the data you have (recursive)

{nbsp}

Fit models to the data

{nbsp}

Communicate the results

Patterns in data
----------------

{nbsp}

Known commonly occurring patterns

{nbsp}

Derived from domain knowledge

* expectations of behavior
* hunches
* suspicious behavior seem

Exploration techniques
----------------------

{nbsp}

Visual patterns

{nbsp}

Suck it and see model building

Data patterns
-------------

.Plots of sample values having various patterns.
image::intro-1-data-plot.jpg[]


Simple visualization options
----------------------------

Paired relationships

* <rcode>pairs</rcode>
* correlations

Plotting trend line

* <rcode>loess</rcode>

Density plots

* Computer age histograms

3-D

* heatmaps
* contour plots

pairs function
--------------

Visualise all paired relationships

-----
Name,CFP,Haskell,Abstract,C
seL4_IRQHandler_Ack,6,26,17,68
seL4_TCB_Resume,6,1671,503,1681
seL4_TCB_Suspend,6,1611,479,1607
seL4_ARM_Page_FlushCaches,6,413,211,398
seL4_IRQHandler_Clear,7,1555,381,1609
seL4_TCB_SetPriority,7,219,187,121
-----

Three way pairs
---------------

.Various measurements of work performed implementing the same functionality, number of lines of Haskell and C implementing functionality, CFP (COSMIC function points; based on user manual) and length of formal specification.
image::intro-1-pub-fs-fp.jpg[]


Ada vs. Fortran
---------------

.Effort, in hours (log scale), spent in various development phases of projects written in Ada (blue) and Fortran (red).
image::intro-1-nasa-ada-fortran.jpg[]


Pull request correlations
-------------------------

.Correlations between pairs of attributes of 12,799 Github pull requests to the Homebrew repo.
image::intro-1-pull-req-cor.jpg[]


Trend line
----------

{nbsp}

Values do not always follow a discernible direction

{nbsp}

Averaging line through data

* <rcode>loess</rcode>
* running mean, <rcode>runmed</rcode>
* splines

Methods can give the same answer
--------------------------------

.Relative frequency of cpus when first launched (1970 == 1).
image::intro-1-cpu-freq-over-time.jpg[]


NASA effort pattern
-------------------

.Effort invested in project definition (as percentage of original estimate) against cost overrun (as percentage of original estimate).
image::intro-1-NASA_gruhl.jpg[]


Don't have to be half-way point
-------------------------------

.Year and age at which survey respondents started contributing to FLOSS, i.e., made their first FLOSS contribution.
image::intro-1-msr14-floss-survey.jpg[]


Smoothing the data
------------------

Reduce rapid variations in the data

.SPECint results, summed over all distinct values (left) and summed within equal width bins (right).
image::intro-1-SPEC-hist.jpg[]


Histogram vs density
--------------------

Histogram output depends on

* number of bins
* bin starting point

.Three commonly used kernel density smoothing functions: gaussian, rectangular and triangular.
image::intro-1-kernel.jpg[]


Density plot of SPEC
--------------------

.Kernel density plot of the number of computers having the same SPECint result.
image::intro-1-SPEC-density.jpg[]


Densely packed measurements
---------------------------

.Developer estimated effort against actual effort (in hours), for various maintenance tasks, e.g., adaptive, corrective and perfective; left as-is, middle jittered values and right size proportional to the log of the number measurements.
image::intro-1-maint-est.jpg[]


.Number of files and lines of code in 3,782 projects on Sourceforge.
image::intro-1-herraiz-projects.jpg[]


Boxplots
--------

.Boxplot of time between a bug in Eclipse being reported and the first response to the report; right plot is notched.
image::intro-1-boxplot-10-cscw.jpg[]


Violin plots
------------

.Violin plots (left using rfunc[vioplot], right using rfunc[beanplot]) of time between bug being reported in Eclipse and first response to the report; right plot is notched.
image::intro-1-violinplot-10-cscw.jpg[]


Paired connections
------------------

.Pairs of languages used together in the same GitHub project with connecting line width, color and transparency related to number of occurrences.
image::intro-1-github-lang-pairs.jpg[]


3-Dimensions
------------

{nbsp}

x-y axis only supports two variable visual displays

{nbsp}

Want to visually display information about three variables

Heatmaps
--------

.Intel Sandy Bridge L3 cache bandwidth in GB/s at various clock frequencies and using combinations of cores (0-3 denotes cores zero-through-three, 0,2,4 denotes the three cores zero, two and four).
image::intro-1-heatmap-hotpower.jpg[]


Contour plots
-------------

.Contour plot of the number of sessions executed on a computer having a given processor speed and memory capacity.
image::intro-1-thereska_sipew-procspeed-memsize.jpg[]


